#' @title FeatureSelectionGenetic
#'
#' @format [R6::R6Class] inheriting from [FeatureSelection].
#' @include FeatureSelection.R
#'
#' @description
#' Genetic feature selection wrapper. The comma strategy `(mu, lambda)` selects a new population of size `mu` out of the `lambda > mu` offspring. The plus strategy `(mu + lambda)` uses the joint pool of `mu` parents and `lambda` offspring for selecting `mu` new candidates. Out of those `mu` features, the new `lambda` features are generated by randomly choosing pairs of parents. These are crossed over and `crossover_rate` represents the probability of choosing a feature from the first parent instead of the second parent. The resulting offspring is mutated, i.e., its bits are flipped with probability `mutation_rate`.
#'
#' @section Construction:
#'  ```
#' fs = FeatureSelectionGenetic$new(pe, tm, measure, param_vals)
#' ```
#'
#' For arguments, see [FeatureSelection].
#'
#' @section Fields:
#' See [FeatureSelection].
#'
#' @section Methods:
#' See [FeatureSelection] and additionally:
#'
#' * `$get_result()`\cr Returns best feature set.
#'
#' * `$get_path()`\cr Returns each generation.
#'
#' @section Parameter Values:
#' See [FeatureSelection] and additionally:
#'
#' * `mu` :: `integer(1)`\cr Size of the parent population.
#'
#' * `lambda` :: `integer(1)`\cr Size of the children population.
#'
#' * `crossover_rate` :: `numeric(1)`\cr Probability of choosing a feature from the first parent within the crossover mutation.
#'
#' * `mutation_rate` :: `numeric(1)`\cr Probability of flipping a feature, i.e. switch between selecting / deselecting a feature.
#'
#' * `max_features` :: `integer(1)`\cr Maximum number of features.
#'
#' * `strategy` :: `character(1)`\cr `plus` or `comma`. Indicates whether to use a `(mu, lambda)` or `(mu + lambda)` genetic algorithm.
#'
#' @name FeatureSelectionGenetic
#' @family FeatureSelection
#' @examples
#' task = mlr3::mlr_tasks$get("pima")
#' measures = mlr3::mlr_measures$get(c("classif.acc"))
#' learner = mlr3::mlr_learners$get("classif.rpart")
#' resampling = mlr3::mlr_resamplings$get("cv", param_vals = list(folds = 5L))
#' resampling$instantiate(task)
#' pe = PerformanceEvaluator$new(task, learner, resampling)
#' tm = TerminatorRuntime$new(max_time = 10, units = "secs")
#' fs = FeatureSelectionGenetic$new(pe, tm, measures,
#'   param_vals = list(mu = 10,
#'     lambda = 20,
#'     strategy = "comma"))
#' fs$calculate()
#' fs$get_result()
#' fs$get_path()
#' @export
FeatureSelectionGenetic = R6Class("FeatureSelectionGenetic",
  inherit = FeatureSelection,
  public = list(
    initialize = function(pe, tm, measure, param_vals = list()) {

      super$initialize(id = "genetic_selection",
        pe = pe,
        tm = tm,
        measure = measure,
        param_set = ParamSet$new(list(
          ParamInt$new("mu", tags = "wrapper", default = 10),
          ParamInt$new("lambda", tags = "wrapper", default = 5),
          ParamDbl$new("crossover_rate", lower = 0, upper = 1, tags = "wrapper", default = 0.5),
          ParamDbl$new("mutation_rate", lower = 0, upper = 1, tags = "wrapper", default = 0.05),
          ParamFct$new("strategy", levels = c("comma", "plus"), default = "plus"))),
        param_vals = param_vals
      )

      # Set values to default if missing
      if (is.null(self$param_set$values$mu)) {
        self$param_set$values$mu = self$param_set$default[["mu"]]
      }
      if (is.null(self$param_set$values$lambda)) {
        self$param_set$values$lambda = self$param_set$default[["lambda"]]
      }
      if (is.null(self$param_set$values$crossover_rate)) {
        self$param_set$values$crossover_rate = self$param_set$default[["crossover_rate"]]
      }
      if (is.null(self$param_set$values$mutation_rate)) {
        self$param_set$values$mutation_rate = self$param_set$default[["mutation_rate"]]
      }
      if (is.null(self$param_set$values$strategy)) {
        self$param_set$values$strategy = self$param_set$default[["strategy"]]
      }

      if (self$param_set$values$strategy == "comma" & self$param_set$values$lambda < self$param_set$values$mu) {
        stop("For comma strategy lambda >= mu")
      }

      self$state = private$initialize_states()
    },

    get_result = function() {
      bmr = self$pe$bmr[[1]]$clone()
      if (length(self$pe$bmr) > 1) {
        lapply(self$pe$bmr[2:length(self$pe$bmr)], function(x) bmr$combine(x))
      }
      bmr_best = bmr$best(self$measure)
      list(
        features = bmr_best$task$feature_names,
        performance = bmr_best$aggregate(self$measure))
    },
    get_path = function() {
      lapply(self$pe$bmr, function(bmr) {
        aggr = bmr$aggregate(self$measure)
        order_typ = ifelse(self$measure$minimize, 1, -1)
        aggr = setorderv(aggr, self$measure$id, order = order_typ)[1:self$param_set$values$mu, ]
        performance = aggr[, self$measure$id, with = FALSE][[1]]
        features = lapply(aggr$hash, function(hash_task) bmr$data[hash == hash_task, task][[1]]$feature_names)
        list(
          features = features,
          performance = performance)
      })
    }
  ),
  private = list(
    calculate_step = function() {

      # Generate population depending on strategy
      if (self$param_set$values$strategy == "plus") {
        states = c(self$state, private$generate_states())
      } else if (self$param_set$values$strategy == "comma") {
        states = private$generate_states()
      }

      # Convert 0/1 states to feature names
      named_states = lapply(self$state, function(state) {
        self$pe$task$feature_names[as.logical(state)]
      })

      # Evaluation
      private$eval_states_terminator(named_states)
      bmr = self$pe$bmr[[length(self$pe$bmr)]]

      # Select mu best results
      aggr = bmr$aggregate(self$measure)
      order_typ = ifelse(self$measure$minimize, 1, -1)
      aggr = setorderv(aggr, self$measure$id, order = order_typ)[1:self$param_set$values$mu, ]

      # Convert feature names to 0/1 encoding and set state
      features = lapply(aggr$hash, function(hash_task) {
        bmr$data[hash == hash_task, task][[1]]$feature_names
      })
      self$state = lapply(features, function(y) {
        as.numeric(Reduce("|", lapply(y, function(x) x == self$pe$task$feature_names)))
      })
    },
    initialize_states = function() {
      lapply(seq_len(self$param_set$values$mu), function(i) {
        if (is.na(self$param_set$values$max_features)) {
          return(rbinom(length(self$pe$task$feature_names), 1, 0.5))
        }
        x = Inf
        while (sum(x) >= self$param_set$values$max_features) {
          x = rbinom(length(self$pe$task$feature_names), 1, 0.5)
        }
        return(x)
      })
    },
    generate_states = function() {
      lapply(seq_len(self$param_set$values$lambda), function(i) {
        while (TRUE) {
          # Randomly select parents
          parents = sample(1:length(self$state), 2, replace = TRUE)

          # Crossover
          cross = rbinom(length(self$state[[parents[1]]]), 1, self$param_set$values$crossover_rate)
          children = ifelse(cross == 1, self$state[[parents[1]]], self$state[[parents[2L]]])

          # Mutation
          mutation = rbinom(length(self$state[[parents[1]]]), 1, self$param_set$values$mutation_rate)
          children = (children + mutation) %% 2

          # Check zero and max features
          if (sum(children) > 0 & (is.na(self$param_set$values$max_features) || sum(children) <= self$param_set$values$max_features)) {
            break
          }
        }
        return(children)
      })
    }
  )
)
